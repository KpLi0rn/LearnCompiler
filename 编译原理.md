# 编译原理

## 说在前面

编译原理是看到 leveryd 师傅的wx公众号提到优先级较高的学科，所以乘此机会看看，感觉会经常用到

## 编译器的前端技术

该章节主要是学习了编译的前段部分，我个人理解就是对代码进行规整，确认真实含义，确保能被计算机所解析

首先在程序中关键字、标识符、特殊字符这些都统称 token，例如下面的小demo，下面的每个都是一个 token，例如 include 这种

`#include<stdio.h>`

主要有三个部分：

1. 词法分析

说人话就是把代码中各个类型的字符都进行区分分析，例如：字符(age)、数字(21)、符号(>=)

即计算机如何识别如上这些字符的，主要有两种办法：正则文法（利用正则匹配字符串，例如数字就是 \d+ 这种）、有限自动机（分别有多种状态，当遇到不同状态的字符的时候就会自动进行切换到对应的状态机来进行处理）



2. 语法分析

说人话就是语法... 英语中的语法中文中的语法，主谓宾，即程序中如何理解 2+3*5 这样子的先后顺序的

在语法分析中主要是构造成一根树，一个程序就是一个树，即**抽象语法树** AST 

我们可以通过遍历树的节点来获取到准确的信息，向下图的话先通过遍历子节点来获取到 3*5 然后再回到根节点执行 + 运算

![image-20211223213327292](https://cdn.wjlshare.com/image-20211223213327292.png)

可以用来解析 XML 、JSON 等数据

![image-20211223213429016](https://cdn.wjlshare.com/image-20211223213429016.png)

3. 语义分析

确定代码真正的本意，确定数据类型，确定变量作用域等等

![image-20211223214429987](https://cdn.wjlshare.com/image-20211223214429987.png)





词法分析是把程序分割成一个个 Token 的过程，可以通过构造有限自动机来实现。

语法分析是把**程序的结构识别出来**（这个说的很形象），并形成一棵便于由计算机处理的抽象语法树。可以用递归下降的算法来实现。

语义分析是消除语义模糊，生成一些属性信息，让计算机能够依据这些信息生成目标代码



这节课还是偏理论，道理明白了但是实际的没有清晰的认知

ps：有点理解局部变量和全局变量了，局部变量就是在当前函数的这个子树里，全局变量可以理解为在最上面那个树，不知道这样理解对不对

## 纯手工打造词法分析器

如何把一连串的字符拆分成一个个 token 

主要逻辑是这样的

![image-20211224081356805](https://cdn.wjlshare.com/image-20211224081356805.png)



代码算是模仿完了...感觉要自己从0开始写还是有些困难

https://github.com/KpLi0rn/LearnCompiler/blob/main/JavaCompiler/src/main/java/class2/SimpleLexer.java

写下来整体学习到了状态机切换

首先就是状态机的初始化，针对几种情况进行保留，例如 int 的关键字时的特殊处理

通过4个状态机来确定 int （id_int1 => 确定n , id_int2 => 确定 t, id_int3 => 确定空格, int 最终确定int）

因为实际情况有可能 int age =xxx 、intsidon 、ixx 等情况，都需要做区分

整体的思路主要是，识别到特定字符串状态机开启，一直往下读，如果遇到别的变量那么就切换状态机

总体梳理一下思路：



