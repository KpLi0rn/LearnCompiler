# 编译原理

## 说在前面

编译原理是看到 leveryd 师傅的wx公众号提到优先级较高的学科，所以乘此机会看看，感觉会经常用到

## 编译器的前端技术

该章节主要是学习了编译的前段部分，我个人理解就是对代码进行规整，确认真实含义，确保能被计算机所解析

首先在程序中关键字、标识符、特殊字符这些都统称 token，例如下面的小demo，下面的每个都是一个 token，例如 include 这种

`#include<stdio.h>`

主要有三个部分：

1. 词法分析

说人话就是把代码中各个类型的字符都进行区分分析，例如：字符(age)、数字(21)、符号(>=)

即计算机如何识别如上这些字符的，主要有两种办法：正则文法（利用正则匹配字符串，例如数字就是 \d+ 这种）、有限自动机（分别有多种状态，当遇到不同状态的字符的时候就会自动进行切换到对应的状态机来进行处理）



2. 语法分析

说人话就是语法... 英语中的语法中文中的语法，主谓宾，即程序中如何理解 2+3*5 这样子的先后顺序的

在语法分析中主要是构造成一根树，一个程序就是一个树，即**抽象语法树** AST 

我们可以通过遍历树的节点来获取到准确的信息，向下图的话先通过遍历子节点来获取到 3*5 然后再回到根节点执行 + 运算

![image-20211223213327292](https://cdn.wjlshare.com/image-20211223213327292.png)

可以用来解析 XML 、JSON 等数据

![image-20211223213429016](https://cdn.wjlshare.com/image-20211223213429016.png)

3. 语义分析

确定代码真正的本意，确定数据类型，确定变量作用域等等

![image-20211223214429987](https://cdn.wjlshare.com/image-20211223214429987.png)





词法分析是把程序分割成一个个 Token 的过程，可以通过构造有限自动机来实现。

语法分析是把**程序的结构识别出来**（这个说的很形象），并形成一棵便于由计算机处理的抽象语法树。可以用递归下降的算法来实现。

语义分析是消除语义模糊，生成一些属性信息，让计算机能够依据这些信息生成目标代码



这节课还是偏理论，道理明白了但是实际的没有清晰的认知

ps：有点理解局部变量和全局变量了，局部变量就是在当前函数的这个子树里，全局变量可以理解为在最上面那个树，不知道这样理解对不对

## 纯手工打造词法分析器

如何把一连串的字符拆分成一个个 token 

主要逻辑是这样的

![image-20211224081356805](https://cdn.wjlshare.com/image-20211224081356805.png)



代码算是模仿完了...感觉要自己从0开始写还是有些困难

https://github.com/KpLi0rn/LearnCompiler/blob/main/JavaCompiler/src/main/java/class2/SimpleLexer.java

12.15：今天利用 go 来写了一下，https://github.com/KpLi0rn/LearnCompiler/tree/main/GoCompiler （前前后后又弄了 2个多小时，唉没办法人笨只能多花时间 ....）

自己重新写的话注意到了很多细节，也发现了一些坑点，昨天用 java 写了一遍之后感觉思路还不是很清晰，今天 go 写完一遍思路清楚些了

编写简单的词法分析器来处理：`int age = 18;`

在上面这串 code 中每个都是 token 即 int、age、=、18、; 

所以我们需要定义 类/结构体 来描述 Token，由于是词法分析器，所以我们不光要知道值还要知道对应的类型

例如：int => 关键字 age=> 变量 .....



所以需要构造如下结来描述 token：

```go
// go 
type SimpleToken struct {
	Type string
	Text string
}
```

```java
// java
private final class SimpleToken implements Token{
  private String text = null;
  private TokenType type = null;

  @Override
  public TokenType getType() {
    return type;
  }

  @Override
  public String getText() {
    return text;
  }
}
```

期望得到的结果为：

```go
{
  Type: int
  Text: int
}

{
  Type: Identifier
  Text: age
}
```

然后需要定义状态机，即可 int => age 的时候 状态机的切换，也就是从关键字状态机 => 变量状态机

状态机在 java 中可以利用 enum 定义，在 go 中可以利用 const 来进行定义 ，定义完之后设置状态机的各种状态

状态切换利用 if 来切换，如果下一个字符不是期望的字符那么就切换状态机，当下一个是期望的字符就一直保持该状态即继续进行读取

还有一个比较关键的就是 int 和 age 这种的区分，这里是通过if来一次进行判断，如果后面字符为 n 那么就继续读知道读到 int空格，那么就可以确认 int  这个关键字了 

```go
	if isAlpha(ch) {
		// 解析到关键字开头
		if ch == 'i' {
			state = DfaState2Str[Id_INT1]
		}else {
			state = DfaState2Str[Identifier]
		}
		token.Type = TokenType2Str[Identifier]
		tokenText = append(tokenText, ch)
    
 ....   
    case "Id_INT1":
			if ch == 'n' {
				state = DfaState2Str[Id_INT2]
				token.Type = TokenType2Str[Identifier] 
				tokenText = append(tokenText, ch)
			}else if isAlpha(ch) || isDigit(ch) {
				tokenText = append(tokenText, ch)
			}else {
				state = initToken(ch)
			}
			break
 ....  
```

大致就是这样。。。 遍历传入 string 逐char/rune 进行读取判断



罗列一下我编写的时候遇到的问题

1. Go && Java switch 的差异

   在 java 中如果我们的 state 是 1 那么如果 case 1 中没有代码和break就会继续往下走case

   在 go 中则必须要加 fallthrough ，在处理 = 的时候被这个坑了一下（看代码毛都看不出来，还好debug了一下）

```java
// java
switch (state){
  case 1:
  case 2:
    	code..
      break;
  default:
    
}
```

```go
// go
switch (state){
case 1:
  fallthrough
case 2:
  code...
  break;
default:  
}
```

2. 添加最后一个 token 的时候必须要在 while/for 外面

不然解析的结果就会是 iint ... 这种很奇怪的东西

主要是因为在里面的话就又会进入 initToken 从而造成干扰



## 语法分析（一）：纯手工打造公式计算器

这一章节感觉说的不是那么清晰

在上一章节，通过编写词法分析器将 `int age = 18;` 中每个 Token 都识别了出来并且都存放到了 Tokens 中，下面的代码是衔接上一章的内容

```java
// int res = 2+3*5;
// tokens => {token<Int,int>,token<Identifier,res>,token<Assignment,=>,token<Expression,2+3*5>}
SimpleASTNode node = null;
Token token = tokens.peek();    //预读,读取到 int 
if (token != null && token.getType() == TokenType.Int) {   //匹配Int
  	// token => token<Int,int>
    token = tokens.read();      //消耗掉int, int 没有提供额外信息直接消耗不进行存储 
    if (tokens.peek().getType() == TokenType.Identifier) { //匹配标识符，预读
        // token => token<Identifier,res>
        token = tokens.read();  //消耗掉标识符
        // 创建当前节点，并把变量名记到AST节点的文本值中，
        // 这里新建一个变量子节点也是可以的
        node = new SimpleASTNode(ASTNodeType.IntDeclaration, token.getText());
        token = tokens.peek();  //预读
        if (token != null && token.getType() == TokenType.Assignment) {
            tokens.read();      //消耗掉等号
            SimpleASTNode child = additive(tokens);  //匹配一个表达式
            if (child == null) {
                throw new Exception("invalide variable initialization, expecting an expression");
            }
            else{
                node.addChild(child); // 添加到 ast 树节点中去
            }
        }
    } else {
        throw new Exception("variable name expected");
    }
}
```

通过 peek 来判断下一个 Token 是不是我们期望的值

另外，从上面的代码中我们看到，程序是从一个 Token 的流中顺序读取。代码中的 peek() 方法是预读，只是读取下一个 Token，但并不把它从 Token 流中移除。在代码中，我们用 peek() 方法可以预先看一下下一个 Token 是否是等号，从而知道后面跟着的是不是一个表达式。而 read() 方法会从 Token 流中移除，下一个 Token 变成了当前的 Token



主要是我们需要实现上下文无关性，所以需要确保公示在哪里都可以使用 (这里其实知道终结符和非终结符就能看懂了 )

在过程中，最终终结符会替换调非终结符号，就像这里的 additiveExpression 最终会被若干个 IntLiteral 所替换

```java
additiveExpression
    :   multiplicativeExpression | additiveExpression Plus multiplicativeExpression;

multiplicativeExpression
    :   IntLiteral | multiplicativeExpression Star IntLiteral;
```



非终结符：即可拆分的元素 

终结符：不可拆分 

例子： S->Ap S->Bq A->a A->cA B->b B->dB 则表示：S 为开始符，S，A，B 为非终结符，而p,q,a,b,c,d 为终结符 取自：https://blog.csdn.net/qq_40147863/article/details/88770715



遇到加号就不认识了，不认识了就会回朔，回朔之后又回到 2 ，然后又进行消耗，遇到 + 号又无法识别又回朔

导致一直回到左边形成做递归



根据长度进行适配，优先从最长的开始匹配 

2+3

这里 additiveExpression 有两种选择：

1. int
2. addexpress

先从int的情况开始说，传入都为 token 即 2+3，2 为 int ，查看下一个发现为 +  不符合，进行回溯。

进入 addexpress + int ，解析 token 的时候优先从 非终结符开始，会将非终结符号转化成终结符号

所以就会调用 additiveExpression ，由于一直不满足所以就一直调用，从而导致不停调用 additiveExpression 形成左递归

```java
additiveExpression : int| additiveExpression + int ;
```

要解决问题的话 把 int 和 additiveExpression 换一下就行了 



在编写代码之前需要先建立 AST 节点 接口如下，通过树结构来存放数据

```java
public interface AstNode {

    public AstNode getParent();

    public List<AstNode> getChildren(); 

    public AstNodeType getType();

    public String getText();

}
```

大致思路就是将 tokens 中的值放到树中，就像下面这样

![image-20211227103323768](https://cdn.wjlshare.com/image-20211227103323768.png)

然后遍历树来进行获取最终结果

```bash
Programm Calculator
	Additive +
		IntLiteral 2
		Multiplicative *
			IntLiteral 3
			IntLiteral 5
Calculating: Programm
	Calculating: Additive
		Calculating: IntLiteral
		Result: 2
		Calculating: Multiplicative
			Calculating: IntLiteral
			Result: 3
			Calculating: IntLiteral
			Result: 5
		Result: 15
	Result: 17
Result: 17
```



递归下降算法：

通过不断递归不断拆分非终结符，直至变为终结符为止。

利用树结构不断向下进行递归遍历

## 语法分析（二）：解决二元表达式的难点



这一章主要介绍了几个点：

1. 巴科斯范式
2. 如何消除左递归

左递归：表达式在左边

右递归，即表达式在右边，在表达式中会优先深度遍历表达式中的内容，从而导致右边的表达式优先计算完成，这样就导致了右递归，表达式在哪边就是往哪边递归的

如果是右递归的话：1+2+3 中先计算了 2+3

巴科斯范式

```java
add ::= mul | add + mul
mul ::= pri | mul * pri
pri ::= Id | Num | (add) 
```



左结合递归放左边

右结合递归放右边

相当于抛一个返回值来进行处理 



前面的解决方案可以看出由于是右递归，所以先计算的是最后两个，这样的话就和我们预期的结合不一致了

![image-20211227162541451](https://cdn.wjlshare.com/image-20211227162541451.png)

所以我们要改成左递归，但是左递归又会造成问题所以需要解决一下

这个利用 EBNF 来写的话就是 `add -> mul (+ mul)*` 

和之前的一个最明显的区别就是 这时候，node 下增加的一个为 + 一个为值，之前右递归是两个都是为数值

```java
    public SimpleAstNode additive(TokenReader tokens) throws Exception{
        SimpleAstNode child1 = multiplicative(tokens);
        SimpleAstNode node = child1; // 乘法子树
        if (child1 != null){
            while(true){
                Token token = tokens.peek();
                if (token!=null && token.getType() == TokenType.Plus){ // 如果是 + 号
                    token = tokens.read(); // 对加号进行消耗
                    SimpleAstNode child2 = multiplicative(tokens); //
                    node = new SimpleAstNode(AstNodeType.Additive,token.getText()); 
                    node.addChildren(child1);
                    node.addChildren(child2);
                    child1 = node; 
                }else {
                    break;
                }
            }

        }
        return node;
    }
```

## 语法分析（三）：实现简单的脚本语言

利用扩展巴恩斯范式来定义变量声明表达式 ，问号代表 0/1 个 

`intDeclaration : 'int' Id ( '=' additiveExpression)? ';';`

前两节都弄清楚的话，这一章节就很容易了 ，

```java
    public SimpleAstNode assignmentStatement(SimpleTokenReader tokens) throws Exception{
        SimpleAstNode node = null;
        SimpleToken token = (SimpleToken) tokens.peek();
        if (token.getType().equals(TokenType.Int)){
            tokens.read(); // 消耗
            token = (SimpleToken) tokens.peek();
            if (token != null && token.getType().equals(TokenType.Identifier)){
                tokens.read();
                node = new SimpleAstNode(AstNodeType.Identifier,token.getText()); // num 为根节点
                token = (SimpleToken) tokens.peek();
                if (token != null && token.getType().equals(TokenType.Assignment)){
                    int position = tokens.getPosition();
                    tokens.read();
                    Calculator calculator = new Calculator();
                    SimpleAstNode child = calculator.additive(tokens);
                    if (child != null){
                        node.addChildren(child);
                        token = (SimpleToken) tokens.peek();
                        // 检测到分号语句结束
                        if (token != null && token.getType().equals(TokenType.SemiColon)){
                            tokens.read();
                        }else {
                            throw new Exception("invalid statement, expecting semicolon");
                        }
                    }else {
                        node = null;
                        tokens.setPosition(position); // 对初始位置进行回朔
                    }
                }
            }
        }
        return node;
    }
```





## 回顾



## 编译器前端工具（一）：使用 Antlr 生成词法语法分析器



/Users/kpli0rn/.m2/repository/org/antlr/antlr4-runtime/4.9.3/antlr4-runtime-4.9.3.jar
